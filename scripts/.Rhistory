install.packages("subplex")
install.packages(c("deSolve", "fs", "igraph", "mvtnorm", "nlme"))
install.packages("rr2")
library(castor)
library(ape)
library(phytools)
library(geiger)
# This function will generate a Q matrix which has all the parameters that
# describes chromosoe number evolution
getQ <- function (data = NULL,
hyper = NULL,
polyploidy = NULL) {
parMat <- matrix(0, ncol(data), ncol(data))
colnames(parMat) <- colnames(data)
rownames(parMat) <- colnames(parMat)
split <- ncol(parMat)/2
if (hyper == T)
chroms <- as.numeric(colnames(data)[1:split])
if (hyper == F)
chroms <- as.numeric(colnames(data))
if (hyper == F) {
print("Constraining model to simple chromevol version")
for (i in 1:(nrow(parMat) - 1)) {
if ((chroms[i] * 2) <= max(chroms))
parMat[i, which(chroms == (chroms[i] * 2))] <- 5
if (constrain$drop.demi == F) {
if ((ceiling(chroms[i] * 1.5)) <= max(chroms)) {
x <- chroms[i] * 1.5
if (x%%1 == 0)
parMat[i, which(chroms == x)] <- 10
if (x%%1 != 0)
parMat[i, which(chroms %in% c(floor(x), ceiling(x)))] <- 11
}
}
parMat[i, (i + 1)] <- 1
parMat[(i + 1), i] <- 2
}
}
if (hyper == T & polyploidy == T) {
print("Creating rate matrix for chosen chromosome model")
for (i in 1:(split - 1)) {
if ((chroms[i] * 2) <= max(chroms))
parMat[i, (which(chroms[i] * 2 == chroms) + split)] <- 5
if ((ceiling(chroms[i] * 1.5)) <= max(chroms)) {
x <- chroms[i] * 1.5
if (x%%1 == 0)
parMat[i, (which(chroms == x) + split)] <- 10
if (x%%1 != 0)
parMat[i, (which(chroms %in% c(floor(x), ceiling(x))) +
split)] <- 11
}
parMat[i, (i + 1)] <- 1
parMat[(i + 1), i] <- 2
}
for (i in (split + 1):(nrow(parMat) - 1)) {
if ((chroms[i - split] * 2) <= max(chroms))
parMat[i, (which(chroms[i - split] * 2 == chroms) +
split)] <- 6
if ((ceiling(chroms[i - split] * 1.5)) <= max(chroms)) {
x <- chroms[i - split] * 1.5
if (x%%1 == 0)
parMat[i, (which(chroms == x) + split)] <- 12
if (x%%1 != 0)
parMat[i, (which(chroms %in% c(floor(x), ceiling(x))) +
split)] <- 13
}
parMat[i, (i - split)] <- 7
if (i == (nrow(parMat) - 1))
parMat[(i + 1), (i + 1 - split)] <- 7
parMat[i, (i + 1)] <- 3
parMat[(i + 1), i] <- 4
}
}
if (hyper == T & polyploidy == F) {
print("Creating rate matrix for chosen chromosome model")
for (i in 1:(split - 1)) {
if ((chroms[i] * 2) <= max(chroms))
parMat[i, which(chroms == (chroms[i] * 2))] <- 5
if ((ceiling(chroms[i] * 1.5)) <= max(chroms)) {
x <- chroms[i] * 1.5
if (x%%1 == 0)
parMat[i, which(chroms == x)] <- 10
if (x%%1 != 0)
parMat[i, which(chroms %in% c(floor(x), ceiling(x)))] <- 11
}
parMat[i, (i + split)] <- 8
if (i == (split - 1))
parMat[(i + 1), (i + 1 + split)] <- 8
parMat[i, (i + 1)] <- 1
parMat[(i + 1), i] <- 2
}
for (i in (split + 1):(nrow(parMat) - 1)) {
if ((chroms[i - split] * 2) <= max(chroms))
parMat[i, (which(chroms[i - split] * 2 == chroms) +
split)] <- 6
if ((ceiling(chroms[i - split] * 1.5)) <= max(chroms)) {
x <- chroms[i - split] * 1.5
if (x%%1 == 0)
parMat[i, (which(chroms == x) + split)] <- 12
if (x%%1 != 0)
parMat[i, (which(chroms %in% c(floor(x), ceiling(x))) +
split)] <- 13
}
parMat[i, (i - split)] <- 9
if (i == (nrow(parMat) - 1))
parMat[(i + 1), (i + 1 - split)] <- 9
parMat[i, (i + 1)] <- 3
parMat[(i + 1), i] <- 4
}
}
return(parMat)
}
library(castor)
library(ape)
library(phytools)
library(geiger)
#-------Make Some Data---------
tree <- sim.bdtree(b=3,d=0, stop="taxa",n=25)
tree$edge.length <- tree$edge.length/max(branching.times(tree))
Q <- matrix(0,10,10)
rate <- 1.5
for(i in 1:10){# rows
for(j in 1:10){# columns
if((i+1) == j){
Q[i,j] <- rate
}
if(i==(j+1)){
Q[i,j] <- rate
}
}
}
diag(Q) <- -rowSums(Q)
colnames(Q) <- 1:10
rowSums(Q)
tip.states<- sim.char(phy=tree, par=Q, root=5, model="discrete")[,,1]
rm(list=ls()[-c(3,5,6)])
tree <- sim.bdtree(b=3,d=0, stop="taxa",n=25)
tree$edge.length <- tree$edge.length/max(branching.times(tree))
plot(tree)
Q <- matrix(0,10,10)
rate <- 1.5
for(i in 1:10){# rows
for(j in 1:10){# columns
if((i+1) == j){
Q[i,j] <- rate
}
if(i==(j+1)){
Q[i,j] <- rate
}
}
}
diag(Q) <- -rowSums(Q)
colnames(Q) <- 1:10
rowSums(Q)
tip.states<- sim.char(phy=tree, par=Q, root=5, model="discrete")[,,1]
rm(list=ls()[-c(3,5,6)])
#--------This is your Function-----
GetTipRates <- function(tree, Q, tip.states){
recon <- asr_mk_model( tree = tree,
tip_states = tip.states,
transition_matrix = Q,
Nstates = ncol(Q),
include_ancestral_likelihoods = TRUE)
est <- c()
for(i in 1:nrow(recon$ancestral_likelihoods)){
est[i] <- which.max(as.vector(recon$ancestral_likelihoods[i,]))
}
## first get the node numbers of the tips
tips <- tree$tip.label
nodes<-sapply(tips,function(x,y) which(y==x),y=tree$tip.label)
## then get the edge lengths for those nodes
edge.lengths<-setNames(tree$edge.length[sapply(nodes,
function(x,y) which(y==x),y=tree$edge[,2])],names(nodes))
tiprates <- nodepulls <- c()
for(i in 1:length(tree$tip.label)){
nodepulls[i] <- getParent(tree, nodes[i])-length(tree$tip.label)
}
tip.changes <- abs(est[nodepulls]-tip.states)
names(tip.changes) <- tree$tip.label
tiprate <- tip.changes/edge.lengths
return(tiprate)
}
rates <- GetTipRates(tree=tree,Q=Q, tip.states=tip.states)
plotTree.barplot(tree, rates, tip.labels=F)
tiplabels(text=tip.states,adj=c(0,.5), cex=.8, frame="none")
#read in the libraries needed for the analysis
library(data.table)
library(evobiR)
setwd("/Volumes/michelle/PAR")
#read in the libraries needed for the analysis
library(data.table)
library(evobiR)
#read in the vcf file
#fread is nice because it removes all the unecessary header lines at the
#beginning of the vcf file
het <- fread("ERR5101147_1.vcf")
#code that identifies the two chromosomes
#each species should have an autosome (chromosome 3)
#and the x chromosome
unique(het$`#CHROM`)
#separate out chromosome 3 from the x chromosome
chrom.auto <- which(het$`#CHROM` == unique(het$`#CHROM`)[1])
chrom.auto.het <- het[chrom.auto, ]
chrom.x <- which(het$`#CHROM` == unique(het$`#CHROM`)[2])
chrom.x.het <- het[chrom.x, ]
#filter the quality of the variant calls by only allowing quality greater than
#20 which equivalent to a 1% false positive chance of the call
chrom.x.het <- chrom.x.het[chrom.x.het$QUAL > 20, ]
#find the average read depth across the autosome (chr3)
length.x <- 156040895
#make a vector with the right length and fill it in with zeros
foo <- rep(0, times =length.x)
#go back through and replace all those sites that are heterozygous with 1
foo[chrom.x.het$POS] <- 1
rm(foo)
#make a vector with the right length and fill it in with zeros
het.all <- rep(0, times =length.x)
#go back through and replace all those sites that are heterozygous with 1
het.all[chrom.x.het$POS] <- 1
FUN <- function(standardized){
mean_slide <- mean(standardized, na.rm = TRUE)
return(mean_slide)
}
test <- SlidingWindow(FUN, het.all, window = 50000, step = 2500)
#plot the test results from the sliding window
plot(test,type="l", ylim = c(0,2))
#plot the test results from the sliding window
plot(test,type="l", ylim = c(0,0.25))
#plot the test results from the sliding window
plot(test,type="l", ylim = c(0,0.1))
pos <- (1:62397)*2500+50000
plot(test~pos)
plot(test~pos, type="l")
abline(v=2600000)
abline(v=2600000, col = "red")
test <- SlidingWindow(FUN, het.all, window = 90000, step = 10000)
#plot the test results from the sliding window
plot(test,type="l", ylim = c(0,0.1))
pos <- (1:15596)*10000+90000
plot(test~pos, type="l")
abline(v=2600000, col = "red")
test <- SlidingWindow("mean", het.all, window = 90000, step = 10000)
#plot the test results from the sliding window
plot(test,type="l", ylim = c(0,0.1))
pos <- (1:15596)*10000+90000
plot(test~pos, type="l")
abline(v=2600000, col = "red")
library(evobiR)
help("GetTipRates")
setwd("~/Documents/GitHub/carnivores/scripts")
#load in libraries
library(beeswarm)
#load in data needed
carn <- read.csv("../../data/Carn_data_incomplete.csv")
#prune data to only informative columns for this plot
carn_prune <- carn[,-c(2:3,6:9,12:36)]
#load in data needed
carn <- read.csv("../data/Carn_data_incomplete.csv")
#prune data to only informative columns for this plot
carn_prune <- carn[,-c(2:3,6:9,12:36)]
#subset out species with small range size
carn_small <- carn_prune[carn_prune$rangesize == "0",]
#calculate the mean population size in species with small range size
mean_smallRS <- mean(carn_small$final.pop, na.rm = T)
#subset out species with large range size
carn_large <- carn_prune[carn_prune$rangesize == "1",]
#calculate the mean population size in species with large range size
mean_largeRS <- mean(carn_large$final.pop, na.rm = T)
#store the small range sizes in a vector
hitsmall <- which(carn_prune$rangesize == "0")
#change all the small range sizes to "name "Small Range Size" instead of 0
carn_prune[hitsmall, 5] <- "Small Range Size"
#store the large range sizes in a vector
hitlarge <- which(carn_prune$rangesize == "1")
#change all the small range sizes to "name "Small Range Size" instead of 0
carn_prune[hitlarge, 5] <- "Large Range Size"
#create a beeswarm plot of the data
beeswarm(log(carn_prune$final.pop)~carn_prune$rangesize,
pch = 16,
xlab = "",
ylab = "Estimated Population Size")
segments(x0 = 0.9,
y0 = log(mean_largeRS),
x1 = 1.1,
y1 = log(mean_largeRS),
lwd = 3)
segments(x0 = 1.9,
y0 = log(mean_smallRS),
x1 = 2.1,
y1 = log(mean_smallRS),
lwd = 3)
#subset out largest large range size species
which(max(carn_large$rangesize))
max(carn_large$rangesize)
View(carn_large)
#subset out largest large range size species
which(max(carn_large$final.pop))
max(carn_large$final.pop)
max(carn_large$final.pop, na.rm = T)
help("which")
#subset out largest large range size species
which(max(carn_large$final.pop, na.rm = T))
max(carn_large$final.pop, na.rm = T)
#subset out largest large range size species
which.max(carn_large$final.pop, na.rm = T)
#subset out largest large range size species
which.max(carn_large$final.pop)
View(carn_large)
#subset out largest large range size species
carn_large_nomax <- carn_large[-c(which.max(carn_large$final.pop)),]
View(carn_large_nomax)
View(carn_large)
#calculate the mean population size with the outlier taken out
mean_largeRS_nomax <- mean(carn_large_nomax$final.pop, na.rm = T)
#create a beeswarm plot of the data
beeswarm(log(carn_prune$final.pop)~carn_prune$rangesize,
pch = 16,
xlab = "",
ylab = "Estimated Population Size")
segments(x0 = 0.9,
y0 = log(mean_largeRS),
x1 = 1.1,
y1 = log(mean_largeRS),
lwd = 3)
segments(x0 = 1.9,
y0 = log(mean_smallRS),
x1 = 2.1,
y1 = log(mean_smallRS),
lwd = 3)
segments(x0 = 0.9,
y0 = log(mean_largeRS_nomax),
x1 = 1.1,
y1 = log(mean_largeRS_nomax),
lwd = 3,
col = "Red")
