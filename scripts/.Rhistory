chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
#empty vector to store diversitree likelihood
p.mat <- list()
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
p.mat[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
}
#read in chromeplus data
chromplus <- read.csv("../results/rangesize.csv")
#get the ancestral states
source("getQ.function.R")
tiprates <- list()
for(i in 1:length(p.mat)){
#create Q matrix from given data
Q <- getQ(data = p.mat[[1]],
hyper = T,
polyploidy = F)
# here there are rates that we are not interested at
# discard them from the table
Q[!(Q %in% c(1,2,3,4,8,9))] <- 0
# fill the qmat
Q[Q == 1] <- mean(chromplus$asc1)
Q[Q == 2] <- mean(chromplus$desc1)
Q[Q == 3] <- mean(chromplus$asc2)
Q[Q == 4] <- mean(chromplus$desc2)
Q[Q == 8] <- mean(chromplus$tran12)
Q[Q == 9] <- mean(chromplus$tran21)
# fill the diagonal so that row sums are zero
diag(Q) <- -rowSums(Q)
#calculate tip rates given the probability and Q matrix
tiprates[[i]] <- GetTipRates(tree = trees[[i]],
Q = Q,
tip.states = NULL,
p.mat = p.mat[[i]],
hyper = T)
}
i <- 1
#create Q matrix from given data
Q <- getQ(data = p.mat[[1]],
hyper = T,
polyploidy = F)
# here there are rates that we are not interested at
# discard them from the table
Q[!(Q %in% c(1,2,3,4,8,9))] <- 0
# fill the qmat
Q[Q == 1] <- mean(chromplus$asc1)
Q[Q == 2] <- mean(chromplus$desc1)
Q[Q == 3] <- mean(chromplus$asc2)
Q[Q == 4] <- mean(chromplus$desc2)
Q[Q == 8] <- mean(chromplus$tran12)
Q[Q == 9] <- mean(chromplus$tran21)
# fill the diagonal so that row sums are zero
diag(Q) <- -rowSums(Q)
tree <- trees[[1]]
tip.states = NULL
p.met <- p.met[[1]]
p.mat <- p.mat[[1]]
hyper <- T
#if the tree is not ultrametric, stop function and ask user to resolve
if(is.ultrametric(tree) == FALSE){
stop("\n Tree is not ultrametric. Please use a formal method to ultrametricize your tree.
If your tree is failing is.ultrametric due to rounding, you can use force.ultrametric,
but this does not serve as a substitute for formal rate-smoothing methods.")
}
#if tip states are null, stop function and ask user to resolve
if(is.null(tip.states) && is.null(p.mat)){
stop("\n Tip states are not present. Please provide tip states as integers or provide
a probability matrix to create tip states for given data.")
}
#if tip states are not integers, stop function and ask user to resolve
if(is.integer(tip.states)){
stop("\n Tip states are not integers. Please provide tip states as integers.")
}
#if tip states are not present, but a probability matrix is provided, fill in
# tip states using the given probability matrix
if(is.null(tip.states) && !is.null(p.mat)){
#create vector to store tip states in
tip.states <- c()
#create tip states from probability matrix
for(i in 1:nrow(p.mat)){
tip.states[i] <- which(p.mat[i,] == 1)}
names(tip.states) <- row.names(p.mat)
}
#empty vector to store the correct order in
hit <- c()
#loop through to store the correct order of the data to match the tree tips
for(j in 1:length(tree$tip.label)){
hit[j] <- which(tree$tip.label[j] == names(tip.states))
}
#reorder the data into the data frame using the correct order
tip.states <- tip.states[hit]
print("Checking the order of tree tip labels and provided data.")
order <- c()
for(i in 1:length(tree$tip.label)){
order[i] <- tree$tip.label[i] == names(tip.states)[i]
}
if(sum(order) == length(tree$tip.label)){
print("Tree tip labels and provided data are in the correct order.")
} else{
print("Tree tip labels and provided data are not in the correct order.")
}
#reconstruct the ancestral states
recon <- asr_mk_model(tree = tree,
tip_states = tip.states,
transition_matrix = Q,
Nstates = ncol(Q),
include_ancestral_likelihoods = T)
# change back the state names to the actual chromosome numbers for tip rate
# calculation
colnames(recon$ancestral_likelihoods) <- colnames(Q)
# if there is a hyper state associated with the model, run additional code to
# calculate tip rates without the hyperstate labels
if(hyper == TRUE){
for(i in 1:ncol(recon$ancestral_likelihoods)){
colnames(recon$ancestral_likelihoods) <- as.numeric(gsub("h",
"",
colnames(recon$ancestral_likelihoods)))
}
}
#store the state names from the ASR in a vector
states <- colnames(recon$ancestral_likelihoods)
#vector to store the transformed tip states
tip.state <- c()
#loop through the integer tip states from 1:Nstates and change them back to
#the actual tip states supplied
for(i in 1:length(tip.states)){
#grabs the tip state that matches the modified tip state for the ASR
tip.state[i] <- states[tip.states[i]]
#ensures that the tip states are numeric
tip.state <- as.numeric(tip.state)
}
#create a vector to store likelihoods at each node
est <- c()
#loop through to store the maximum likelihood at each node
for(i in 1:nrow(recon$ancestral_likelihoods)){
#grabs the maximum likelihood at each node within the supplied tree
est[i] <- which.max(as.vector(recon$ancestral_likelihoods[i,]))
names(est) <- seq(from = 1+length(tree$tip.label), to = length(tree$tip.label)+length(est))
}
#get the node numbers for each of the tips
tips <- tree$tip.label
#store the node number that matches each tip label in a named vector
nodes <- c()
#loop through to store the tip label node numbers
for(i in 1:length(tree$tip.label)){
nodes[i] <- which(tree$tip.label[i] == tips)
}
#name the nodes
names(nodes) <- names(tip.states)
str(recon)
str(recon$transition_matrix)
recon$transition_matrix
recon$ancestral_likelihoods
#get the edge lengths for each node
edge.lengths <- c()
#loop through to store the edge lengths that correspond to each node
edge.lengths <- setNames(tree$edge.length[sapply(nodes,
function(x,y) which(y==x),y=tree$edge[,2])],names(nodes))
#store the parent nodes for each tip
nodepulls <- c()
#loop through to store the parent node of each tip
for(i in 1:length(tree$tip.label)){
nodepulls[i] <- getParent(tree, nodes[i])
}
#store the state at each of the nodes
node.state <- c()
node.states <- c()
#loop through to store the state corresponding to each node
for(i in 1:length(nodepulls)){
node.state[i] <- which(names(est) == nodepulls[i])
#pull the
node.states[i] <- est[node.state[i]]
#pull the actual chromosome number value for each node
node.states[i] <- states[node.states[i]]
#ensures that the node states are numeric
node.states <- as.numeric(node.states)
}
tip.states
tips
node.states[77]
node.states[78]
node.states[82]
node.states[81]
node.states[83]
node.states[80]
tip.state
tip.state[77]
tip.state[78]
tip.state[82]
tip.state[81]
tip.state[83]
tip.state[80]
node.states[71]
node.states[79]
node.states[74]
node.states[76]
node.states[72]
node.states[73]
node.states[758]
node.states[75]
tip.state[71]
tip.state[79]
tip.state[74]
tip.state[76]
tip.state[72]
tip.state[73]
tip.state[75]
nodepulls[77]
plot(tree, cex = 0.5)
nodepulls[78]
nodepulls[82]
nodepulls[81]
nodepulls[83]
nodepulls[80]
nodepulls[71]
nodepulls[79]
est[node.state[169]]
recon$ancestral_likelihoods
plot(tree, cex = 0.5, nodelabels())
plot(tree, cex = 0.5, nodelabels= T)
plot(tree, cex = 0.5, show.node.label = T)
plot(tree, show.node.label = T)
plot(tree, cex = 0.5)
nodelabels()
plot(tree, cex = 0.5)
nodelabels(cex = 0.5)
nodepulls[774]
nodepulls[74]
nodepulls[76]
nodepulls[72]
nodepulls[73]
nodepulls[75]
#create a vector to store likelihoods at each node
est <- c()
#loop through to store the maximum likelihood at each node
for(i in 1:nrow(recon$ancestral_likelihoods)){
#grabs the maximum likelihood at each node within the supplied tree
est[i] <- which.max(as.vector(recon$ancestral_likelihoods[i,]))
names(est) <- seq(from = 1+length(tree$tip.label), to = length(tree$tip.label)+length(est))
}
#get the node numbers for each of the tips
tips <- tree$tip.label
#store the node number that matches each tip label in a named vector
nodes <- c()
#loop through to store the tip label node numbers
for(i in 1:length(tree$tip.label)){
nodes[i] <- which(tree$tip.label[i] == tips)
}
#name the nodes
names(nodes) <- names(tip.states)
#get the edge lengths for each node
edge.lengths <- c()
#loop through to store the edge lengths that correspond to each node
edge.lengths <- setNames(tree$edge.length[sapply(nodes,
function(x,y) which(y==x),y=tree$edge[,2])],names(nodes))
i <- 1
which.max(as.vector(recon$ancestral_likelihoods[i,]))
as.vector(recon$ancestral_likelihoods[i,])
load("../data/datalists_range.RData")
#0 = small; 1 = large pop size
#load in tree data
trees <- read.nexus("../data/carnivorapruned.nex")
#load in tree depths
tree.depths <- read.csv("../data/treedepths.csv")
colnames(tree.depths) <- c("tree", "tree.depth")
#store chrom.range
chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
#empty vector to store diversitree likelihood
p.mat <- list()
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
p.mat[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
}
#read in chromeplus data
chromplus <- read.csv("../results/rangesize.csv")
#get the ancestral states
source("getQ.function.R")
i <- 1
tiprates <- list()
#create Q matrix from given data
Q <- getQ(data = p.mat[[1]],
hyper = T,
polyploidy = F)
# here there are rates that we are not interested at
# discard them from the table
Q[!(Q %in% c(1,2,3,4,8,9))] <- 0
# fill the qmat
Q[Q == 1] <- mean(chromplus$asc1)
Q[Q == 2] <- mean(chromplus$desc1)
Q[Q == 3] <- mean(chromplus$asc2)
Q[Q == 4] <- mean(chromplus$desc2)
Q[Q == 8] <- mean(chromplus$tran12)
Q[Q == 9] <- mean(chromplus$tran21)
# fill the diagonal so that row sums are zero
diag(Q) <- -rowSums(Q)
tree = trees[[i]],
Q = Q,
tip.states = NULL,
p.mat = p.mat[[i]],
hyper = T
tree = trees[[i]],
Q = Q,
tip.states = NULL,
p.mat = p.mat[[i]],
hyper = T
tree = trees[[i]]
Q = Q
tip.states = NULL
p.mat = p.mat[[i]]
hyper = T
if(is.ultrametric(tree) == FALSE){
stop("\n Tree is not ultrametric. Please use a formal method to ultrametricize your tree.
If your tree is failing is.ultrametric due to rounding, you can use force.ultrametric,
but this does not serve as a substitute for formal rate-smoothing methods.")
}
#if tip states are null, stop function and ask user to resolve
if(is.null(tip.states) && is.null(p.mat)){
stop("\n Tip states are not present. Please provide tip states as integers or provide
a probability matrix to create tip states for given data.")
}
#if tip states are not integers, stop function and ask user to resolve
if(is.integer(tip.states)){
stop("\n Tip states are not integers. Please provide tip states as integers.")
}
#if tip states are not present, but a probability matrix is provided, fill in
# tip states using the given probability matrix
if(is.null(tip.states) && !is.null(p.mat)){
#create vector to store tip states in
tip.states <- c()
#create tip states from probability matrix
for(i in 1:nrow(p.mat)){
tip.states[i] <- which(p.mat[i,] == 1)}
names(tip.states) <- row.names(p.mat)
}
#loop through to store whether tip states and tree tip labels are matching for
#each tip on the tree
#empty vector to store the correct order in
hit <- c()
#loop through to store the correct order of the data to match the tree tips
for(j in 1:length(tree$tip.label)){
hit[j] <- which(tree$tip.label[j] == names(tip.states))
}
#reorder the data into the data frame using the correct order
tip.states <- tip.states[hit]
#check to see if the tip states and tree tip labels are in the same order
print("Checking the order of tree tip labels and provided data.")
order <- c()
for(i in 1:length(tree$tip.label)){
order[i] <- tree$tip.label[i] == names(tip.states)[i]
}
if(sum(order) == length(tree$tip.label)){
print("Tree tip labels and provided data are in the correct order.")
} else{
print("Tree tip labels and provided data are not in the correct order.")
}
#reconstruct the ancestral states
recon <- asr_mk_model(tree = tree,
tip_states = tip.states,
transition_matrix = Q,
Nstates = ncol(Q),
include_ancestral_likelihoods = T)
colnames(recon$ancestral_likelihoods)
colnames(Q)
load("../data/datalists_range.RData")
#0 = small; 1 = large pop size
#load in tree data
trees <- read.nexus("../data/carnivorapruned.nex")
#load in tree depths
tree.depths <- read.csv("../data/treedepths.csv")
colnames(tree.depths) <- c("tree", "tree.depth")
#store chrom.range
chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
#empty vector to store diversitree likelihood
p.mat <- list()
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
p.mat[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
}
#read in chromeplus data
chromplus <- read.csv("../results/rangesize.csv")
#get the ancestral states
source("getQ.function.R")
tiprates <- list()
i <- 1
#create Q matrix from given data
Q <- getQ(data = p.mat[[1]],
hyper = T,
polyploidy = F)
# here there are rates that we are not interested at
# discard them from the table
Q[!(Q %in% c(1,2,3,4,8,9))] <- 0
# fill the qmat
Q[Q == 1] <- mean(chromplus$asc1)
Q[Q == 2] <- mean(chromplus$desc1)
Q[Q == 3] <- mean(chromplus$asc2)
Q[Q == 4] <- mean(chromplus$desc2)
Q[Q == 8] <- mean(chromplus$tran12)
Q[Q == 9] <- mean(chromplus$tran21)
# fill the diagonal so that row sums are zero
diag(Q) <- -rowSums(Q)
tree = trees[[i]]
Q = Q
tip.states = NULL
p.mat = p.mat[[i]]
hyper = T
if(is.ultrametric(tree) == FALSE){
stop("\n Tree is not ultrametric. Please use a formal method to ultrametricize your tree.
If your tree is failing is.ultrametric due to rounding, you can use force.ultrametric,
but this does not serve as a substitute for formal rate-smoothing methods.")
}
#if tip states are null, stop function and ask user to resolve
if(is.null(tip.states) && is.null(p.mat)){
stop("\n Tip states are not present. Please provide tip states as integers or provide
a probability matrix to create tip states for given data.")
}
#if tip states are not integers, stop function and ask user to resolve
if(is.integer(tip.states)){
stop("\n Tip states are not integers. Please provide tip states as integers.")
}
#if tip states are not present, but a probability matrix is provided, fill in
# tip states using the given probability matrix
if(is.null(tip.states) && !is.null(p.mat)){
#create vector to store tip states in
tip.states <- c()
#create tip states from probability matrix
for(i in 1:nrow(p.mat)){
tip.states[i] <- which(p.mat[i,] == 1)}
names(tip.states) <- row.names(p.mat)
}
#loop through to store whether tip states and tree tip labels are matching for
#each tip on the tree
#empty vector to store the correct order in
hit <- c()
#loop through to store the correct order of the data to match the tree tips
for(j in 1:length(tree$tip.label)){
hit[j] <- which(tree$tip.label[j] == names(tip.states))
}
#reorder the data into the data frame using the correct order
tip.states <- tip.states[hit]
#check to see if the tip states and tree tip labels are in the same order
print("Checking the order of tree tip labels and provided data.")
order <- c()
for(i in 1:length(tree$tip.label)){
order[i] <- tree$tip.label[i] == names(tip.states)[i]
}
if(sum(order) == length(tree$tip.label)){
print("Tree tip labels and provided data are in the correct order.")
} else{
print("Tree tip labels and provided data are not in the correct order.")
}
### --- perform ancestral state reconstruction --- ###
#reconstruct the ancestral states
recon <- asr_mk_model(tree = tree,
tip_states = tip.states,
transition_matrix = Q,
Nstates = ncol(Q),
include_ancestral_likelihoods = T)
help("asr_mk_model")
foo <- recon$ancestral_likelihoods
View(foo)
tree
foo[179,]
foo[69,]
plot(foo[69,])
recon$success
recon$transition_matrix
recon$loglikelihood
recon$AIC
recon$Nstates
plot(foo[68,])
plot(foo[67,])
plot(foo[60,])
plot(foo[10,])
plot(foo[15,])
plot(foo[19,])
plot(foo[23,])
plot(foo[8,])
plot(0,0,col="white",xlim=c(0,60),ylim=c(0,1))
plot(0,0,col="white",xlim=c(0,60),ylim=c(0,1))
for(i in 1:nrow(foo)){
lines(foo[i,], col(rainbow(109)[i]))
}
for(i in 1:nrow(foo)){
lines(foo[i,], col=rainbow(109)[i]))
}
plot(0,0,col="white",xlim=c(0,60),ylim=c(0,1))
for(i in 1:nrow(foo)){
lines(foo[i,], col=rainbow(109)[i])
}
i <- 1
recon$ancestral_likelihoods[i,]
max(recon$ancestral_likelihoods[i,])
which.max(recon$ancestral_likelihoods[i,])
View(foo)
nodvals <- c()
for(i in 1:109){
node.vals[i] <- which.max(recon$ancestral_likelihoods[i,])
}
nodvals <- c()
for(i in 1:109){
nodevals[i] <- which.max(recon$ancestral_likelihoods[i,])
}
nodvals <- c()
for(i in 1:109){
nodvals[i] <- which.max(recon$ancestral_likelihoods[i,])
}
reconabline(v=26.5)
abline(v=26.5)
plot(foo[69,])
plot(y=foo[69,1:26], x= (1:26+14))
plot(foo[60,])
abline(v=26.5)
