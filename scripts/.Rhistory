chroms <- read.csv("../data/chroms.csv")
#load in IUCN data
iucn <- read.csv("../data/iucndata.csv")
###PRUNE DATA###----------------------------------------------------------------
#prune chromosome number and combnine with range size
dat.pruned <- iucn
#add empty third column for chromosome number
dat.pruned[, 3]  <- NA
#name the third column
colnames(dat.pruned)[3] <- "hap.chrom"
# Columns are out of order lets fix them immediately
dat.pruned <- dat.pruned[, c(1, 3, 2)]
colnames(dat.pruned) <- c("species", "hap.chrom", "status")
#this loop creates 100 datasets, sampling a chromosome number for each species
#when there is more than one
datalist <- list()
for(j in 1:100){
for(i in 1:nrow(iucn)){
hit <- which(chroms$species == iucn$name[i])
if(length(hit) > 1){
hit <- sample(hit, 1)
}
dat.pruned$hap.chrom[i] <- chroms[hit, 2]
}
datalist[[j]] <- dat.pruned
}
#rm old data and clean up environment
rm(i, j, chroms, dat.pruned, iucn, hit)
###DISCRETIZE RANGE SIZES###----------------------------------------------------
#discretize range size based on the median
for(i in 1:100){
datalist[[i]]$status[which(!datalist[[i]]$status == "Least Concern")] <- 1
datalist[[i]]$status[which(datalist[[i]]$status == "Least Concern")] <- 0
datalist[[i]]$status <- as.numeric(datalist[[i]]$status)
}
#0 = least concern; 1 = all other iucn statuses
rm(i)
###ORDER TREE AND DATA###-------------------------------------------------------
#loop through to make sure all of the datalists are in the same order as each
#of the trees
for(i in 1:length(datalist)){
#empty vector to store correct order in
neworder <- c()
#loop through to store the correct order of the data to match the tree tips
for(j in 1:length(trees[[i]]$tip.label)){
neworder[j] <- which(trees[[i]]$tip.label[j] == datalist[[i]]$species)
}
#reorder the data into a new data frame
datalist[[i]] <- datalist[[i]][neworder,]
}
#remove variables that aren't needed anymore
rm(i, j, neworder, trees)
#write out the environment to store the data lists
save.image("~/Documents/GitHub/carnivores/data/datalists_iucn.RData")
#load in chromosome number and binary trait data
load("../data/datalists_iucn.RData")
#load in tree data
trees <- read.nexus("../data/carnivorapruned.nex")
#assign prior from exponential distribution
prior <- make.prior.exponential(4)
# from primary analysis we can get our w
w <- c(0.6598417, 0.7470406, 4.915778, 4.435216, 2.065825, 2.17056)
# register cores to use in parallel
registerDoMC(detectCores(all.tests = T) - 3)
#create empty list to store results
result <- list()
#set iter to 300 for the number of steps to take in the model
iter <- 300
#store chrom.range
chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
datalist[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
}
i <- 1
# make the basic likelihood function for the data
lk.mk <- make.mkn(trees[[i]], states = datalist[[i]],
k = ncol(datalist[[i]]), strict = F,
control = list(method = "ode"))
# now we constrain our model to be biologically realistic for
# chromosomes.
con.lk.mk<-constrainMkn(data = datalist[[i]], lik = lk.mk, hyper = T,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
# now we are ready to run our inference run
result[[i]] <- mcmc(con.lk.mk,
x.init = runif(6, 0, 10),
prior = prior,
w = w,
nsteps = iter,
upper = 50,
lower = 0)
datalist[[1]]
argnames(con.lk.mk)
mcmc(con.lk.mk,
x.init =  runif(6, 0, 10),
prior = prior,
w = w,
nsteps = iter,
upper = 50,
lower = 0)
mcmcm(con.lk.mk)
mcmc(con.lk.mk)
mcmc(con.lk.mk,
x.init =  runif(6, 0, 10))
#store chrom.range
chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
library(phytools)
library(chromePlus)
library(diversitree)
library(doMC)
###LOAD IN DATA NEEDED###-------------------------------------------------------
#load in chromosome number and binary trait data
load("../data/datalists_iucn.RData")
#load in tree data
trees <- read.nexus("../data/carnivorapruned.nex")
#assign prior from exponential distribution
prior <- make.prior.exponential(4)
# from primary analysis we can get our w
w <- c(0.6598417, 0.7470406, 4.915778, 4.435216, 2.065825, 2.17056)
# register cores to use in parallel
registerDoMC(detectCores(all.tests = T) - 3)
#create empty list to store results
result <- list()
#set iter to 300 for the number of steps to take in the model
iter <- 300
#store chrom.range
chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
datalist[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
datalist[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
}
help("make.mkn")
ncol(datalist[[i]])
trees[[i]]
datalist[[i]]
# make the basic likelihood function for the data
lk.mk <- make.mkn(trees[[i]], states = datalist[[i]],
k = ncol(datalist[[i]]), strict = F,
control = list(method = "ode"))
# now we constrain our model to be biologically realistic for
# chromosomes.
con.lk.mk<-constrainMkn(data = datalist[[i]], lik = lk.mk, hyper = T,
polyploidy = F, verbose = F,
constrain = list(drop.demi = T, drop.poly = T))
# now we are ready to run our inference run
result[[i]] <- mcmc(con.lk.mk,
x.init = runif(6, 0, 10),
prior = prior,
w = w,
nsteps = iter,
upper = 50,
lower = 0)
mcmc(con.lk.mk,
x.init = runif(6, 0, 1),
prior = prior,
w = w,
nsteps = iter,
upper = 50,
lower = 0)
#load in chromosome number and binary trait data
load("../data/datalists_iucn.RData")
#load in tree data
trees <- read.nexus("../data/carnivorapruned.nex")
###MAKE LIKELIHOOD FUNCTION###--------------------------------------------------
#store chrom.range
chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
datalist[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
}
#make a likelihood function
#states = named vector of character states
#k = number of states to model; 1 to k for make.mkn number of columns in pmat
#strict = T allows for missing states
#control (ode) = uses an ODE based approach to compute only the k variables over
#time; more efficient when k is large
lk.mk <- make.mkn(trees[[52]], states = datalist[[52]],
k = ncol(datalist[[52]]), strict = F,
control = list(method = "ode"))
#constrain the likelihood function to remove states that are not biologically
#realistic
con.lik <- constrainMkn(data = datalist[[52]],
lik = lk.mk,
polyploidy = F,
hyper = T,
constrain = list(drop.demi = T,
drop.poly= T))
#check to make sure we have the parameters we are expecting
argnames(con.lik)
rm(chrom.range, i, lk.mk)
######### FIT 1 TREE AS TEST##########
#assign prior from exponential distribution
prior <- make.prior.exponential(2)
#fit a biologically realistic model using diversitree's mcmc
#con.lik2 = likelihood function for mcmc to run on
#x.init = initial parameter location
#prior = an optional prior probability distribution
#w = tuning parameter for the  sampler
#nsteps = number of  mcmc steps to  take
#upper = upperr bounds on  parameter space
#lower = lower bounds on parameter space
temp <- mcmc(lik = con.lik,
x.init = runif(6, 0, 1),
prior = prior,
w = 10,
nsteps = 300,
upper = 20,
lower = 0)
datalist[[1]]
colnames(datalist[[i]])
colnames(datalist[[1]])
library(phytools)
library(chromePlus)
library(diversitree)
library(doMC)
###LOAD IN DATA NEEDED###-------------------------------------------------------
#load in chromosome number and binary trait data
load("../data/datalists_range.RData")
#0 = small; 1 = large pop size
#load in tree data
trees <- read.nexus("../data/carnivorapruned.nex")
#load in tree depths
tree.depths <- read.csv("../data/treedepths.csv")
colnames(tree.depths) <- c("tree", "tree.depth")
###MAKE LIKELIHOOD FUNCTION###--------------------------------------------------
#store chrom.range
chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
datalist[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
}
#make a likelihood function
#states = named vector of character states
#k = number of states to model; 1 to k for make.mkn number of columns in pmat
#strict = T allows for missing states
#control (ode) = uses an ODE based approach to compute only the k variables over
#time; more efficient when k is large
lk.mk <- make.mkn(trees[[52]], states = datalist[[52]],
k = ncol(datalist[[52]]), strict = F,
control = list(method = "ode"))
###CONSTRAIN LIKELIHOOD FUNCTION###---------------------------------------------
#constrain the likelihood function to remove states that are not biologically
#realistic
con.lik <- constrainMkn(data = datalist[[52]],
lik = lk.mk,
polyploidy = F,
hyper = T,
constrain = list(drop.demi = T,
drop.poly= T))
#check to make sure we have the parameters we are expecting
argnames(con.lik)
rm(chrom.range, i, lk.mk)
######### FIT 1 TREE AS TEST##########
#assign prior from exponential distribution
prior <- make.prior.exponential(2)
#fit a biologically realistic model using diversitree's mcmc
#con.lik2 = likelihood function for mcmc to run on
#x.init = initial parameter location
#prior = an optional prior probability distribution
#w = tuning parameter for the  sampler
#nsteps = number of  mcmc steps to  take
#upper = upperr bounds on  parameter space
#lower = lower bounds on parameter space
temp <- mcmc(lik = con.lik,
x.init = runif(6, 0, 1),
prior = prior,
w = 10,
nsteps = 300,
upper = 20,
lower = 0)
###FULL PARALLEL RUN OF TREES###------------------------------------------------
#tuning parameters for w for full run
tune <- temp[-c(1:100), ]
w <- diff(sapply(tune[2:7],
quantile, c(.05, .95)))
# register cores to use in parallel
registerDoMC(detectCores(all.tests = T) - 3)
#create empty list to store results
result <- list()
#set iter to 300 for the number of steps to take in the model
iter <- 300
library(phytools)
library(chromePlus)
library(diversitree)
library(doMC)
###LOAD IN DATA NEEDED###-------------------------------------------------------
#load in chromosome number and binary trait data
load("../data/datalists_range.RData")
#0 = small; 1 = large pop size
#load in tree data
trees <- read.nexus("../data/carnivorapruned.nex")
#load in tree depths
tree.depths <- read.csv("../data/treedepths.csv")
colnames(tree.depths) <- c("tree", "tree.depth")
###MAKE LIKELIHOOD FUNCTION###--------------------------------------------------
#store chrom.range
chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
datalist[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
}
#make a likelihood function
#states = named vector of character states
#k = number of states to model; 1 to k for make.mkn number of columns in pmat
#strict = T allows for missing states
#control (ode) = uses an ODE based approach to compute only the k variables over
#time; more efficient when k is large
lk.mk <- make.mkn(trees[[52]], states = datalist[[52]],
k = ncol(datalist[[52]]), strict = F,
control = list(method = "ode"))
###CONSTRAIN LIKELIHOOD FUNCTION###---------------------------------------------
#constrain the likelihood function to remove states that are not biologically
#realistic
con.lik <- constrainMkn(data = datalist[[52]],
lik = lk.mk,
polyploidy = F,
hyper = T,
constrain = list(drop.demi = T,
drop.poly= T))
#check to make sure we have the parameters we are expecting
argnames(con.lik)
rm(chrom.range, i, lk.mk)
######### FIT 1 TREE AS TEST##########
#assign prior from exponential distribution
prior <- make.prior.exponential(2)
#fit a biologically realistic model using diversitree's mcmc
#con.lik2 = likelihood function for mcmc to run on
#x.init = initial parameter location
#prior = an optional prior probability distribution
#w = tuning parameter for the  sampler
#nsteps = number of  mcmc steps to  take
#upper = upperr bounds on  parameter space
#lower = lower bounds on parameter space
temp <- mcmc(lik = con.lik,
x.init = runif(6, 0, 1),
prior = prior,
w = 10,
nsteps = 300,
upper = 20,
lower = 0)
#fit a biologically realistic model using diversitree's mcmc
#con.lik2 = likelihood function for mcmc to run on
#x.init = initial parameter location
#prior = an optional prior probability distribution
#w = tuning parameter for the  sampler
#nsteps = number of  mcmc steps to  take
#upper = upperr bounds on  parameter space
#lower = lower bounds on parameter space
temp <- mcmc(lik = con.lik,
x.init = runif(6, 0, 10),
prior = prior,
w = 10,
nsteps = 300,
upper = 20,
lower = 0)
datalist[[1]]
str(datalist)
str(datalist[[1]])
help(make.mkn)
###LOAD IN PACKAGES###----------------------------------------------------------
#load in packages needed to run analysis
library(phytools)
library(chromePlus)
library(diversitree)
library(doMC)
#load in tree data
trees <- read.nexus("../data/carnivora.nex")
for(i in 1:100){
#trees are ultrametric, this line corrects for the fact that the tolerance
#for being ultrametric is not met by some trees
trees[[i]] <- force.ultrametric(trees[[i]], method = "extend")
}
#load in chromosome data
chroms <- read.csv("../data/chroms.csv")
#remove the row with the highest tip rate to drop from the data
chroms <- chroms[-6,]
#load in range size
range <- read.csv("../data/calc.carn.range.sizes.csv")
#remove the row with the highest tip rate to drop from the data
range <- range[-61,]
#change column names to be informative
colnames(range) <- c("species", "range.size")
#load in range size
range <- read.csv("../data/range_size.csv")
#remove the row with the highest tip rate to drop from the data
range <- range[-61,]
#change column names to be informative
colnames(range) <- c("species", "range.size")
View(range)
#prune chromosome number and combnine with range size
dat.pruned <- range
#add empty third column for chromosome number
dat.pruned[, 3]  <- NA
#name the third column
colnames(dat.pruned)[3] <- "hap.chrom"
# TODO columns are out of order lets fix them immediately
dat.pruned <- dat.pruned[, c(1, 3, 2)]
#this loop creates 100 datasets, sampling a chromosome number for each species
#when there is more than one
datalist <- list()
for(j in 1:100){
for(i in 1:nrow(range)){
hit <- which(chroms$species == range$species[i])
if(length(hit) > 1){
hit <- sample(hit, 1)
}
dat.pruned$hap.chrom[i] <- chroms[hit, 2]
}
datalist[[j]] <- dat.pruned
}
#prune and scale trees
#find tips that are missing from the dataset
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% datalist[[1]]$species]
#empty list to store pruned trees
trees.pruned <- list()
#empty vector to store tree depths
#keep tree depths to correct for depth when analysing rates
tree.depths <- c()
#loop that drops missing tips and stores tree depths for further use
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
tree.depths[i] <- max(branching.times(cur.tree))
# a rounding error also makes tree 52 fail due to a multitomy in the genus
# pusa
if(i == 52){
cur.tree <- multi2di(cur.tree)
}
cur.tree$edge.length <-  cur.tree$edge.length / max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
#rm old data and clean up environment
rm(trees, cur.tree, i, j, missing, chroms, dat.pruned, range, hit)
###DISCRETIZE RANGE SIZES###----------------------------------------------------
#discretize range size based on the median
for(i in 1:100){
x <- median(datalist[[1]]$range.size)
datalist[[i]]$range.size <- as.numeric(datalist[[1]]$range.size >= x)
}
#0 = small; 1 = large pop size
rm(i, x)
#store chrom.range
chrom.range <- range(datalist[[52]]$hap.chrom) + c(-1, 1)
#run datatoMatrix function necessary for diversitree likelihood function
for(i in 1:100){
datalist[[i]] <- datatoMatrix(x=datalist[[i]], range = chrom.range, hyper = T)
}
#make a likelihood function
#states = named vector of character states
#k = number of states to model; 1 to k for make.mkn number of columns in pmat
#strict = T allows for missing states
#control (ode) = uses an ODE based approach to compute only the k variables over
#time; more efficient when k is large
lk.mk <- make.mkn(trees.pruned[[52]], states = datalist[[52]],
k = ncol(datalist[[52]]), strict = F,
control = list(method = "ode"))
#constrain the likelihood function to remove states that are not biologically
#realistic
con.lik <- constrainMkn(data = datalist[[52]],
lik = lk.mk,
polyploidy = F,
hyper = T,
constrain = list(drop.demi = T,
drop.poly= T))
#check to make sure we have the parameters we are expecting
argnames(con.lik)
rm(chrom.range, i, lk.mk)
######### FIT 1 TREE AS TEST##########
#assign prior from exponential distribution
prior <- make.prior.exponential(2)
#fit a biologically realistic model using diversitree's mcmc
#con.lik2 = likelihood function for mcmc to run on
#x.init = initial parameter location
#prior = an optional prior probability distribution
#w = tuning parameter for the  sampler
#nsteps = number of  mcmc steps to  take
#upper = upperr bounds on  parameter space
#lower = lower bounds on parameter space
temp <- mcmc(lik = con.lik,
x.init = runif(6, 0, 1),
prior = prior,
w = 10,
nsteps = 300,
upper = 20,
lower = 0)
mcmc(lik = con.lik,
x.init = runif(6, 0, 1),
prior = prior,
w = 10,
nsteps = 300,
upper = 20,
lower = 0)
make.prior.exponential(2)
#fit a biologically realistic model using diversitree's mcmc
#con.lik2 = likelihood function for mcmc to run on
#x.init = initial parameter location
#prior = an optional prior probability distribution
#w = tuning parameter for the  sampler
#nsteps = number of  mcmc steps to  take
#upper = upperr bounds on  parameter space
#lower = lower bounds on parameter space
temp <- mcmc(lik = con.lik,
x.init = runif(6, 0, 1),
prior = prior,
w = 10,
nsteps = 300,
upper = 20,
lower = 0)
help(mcmc)
