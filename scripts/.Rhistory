split)] <- 13
}
parMat[i, (i - split)] <- 7
if (i == (nrow(parMat) - 1))
parMat[(i + 1), (i + 1 - split)] <- 7
parMat[i, (i + 1)] <- 3
parMat[(i + 1), i] <- 4
}
}
if (hyper == T & polyploidy == F) {
print("Creating rate matrix for chosen chromosome model")
for (i in 1:(split - 1)) {
if ((chroms[i] * 2) <= max(chroms))
parMat[i, which(chroms == (chroms[i] * 2))] <- 5
if ((ceiling(chroms[i] * 1.5)) <= max(chroms)) {
x <- chroms[i] * 1.5
if (x%%1 == 0)
parMat[i, which(chroms == x)] <- 10
if (x%%1 != 0)
parMat[i, which(chroms %in% c(floor(x), ceiling(x)))] <- 11
}
parMat[i, (i + split)] <- 8
if (i == (split - 1))
parMat[(i + 1), (i + 1 + split)] <- 8
parMat[i, (i + 1)] <- 1
parMat[(i + 1), i] <- 2
}
for (i in (split + 1):(nrow(parMat) - 1)) {
if ((chroms[i - split] * 2) <= max(chroms))
parMat[i, (which(chroms[i - split] * 2 == chroms) +
split)] <- 6
if ((ceiling(chroms[i - split] * 1.5)) <= max(chroms)) {
x <- chroms[i - split] * 1.5
if (x%%1 == 0)
parMat[i, (which(chroms == x) + split)] <- 12
if (x%%1 != 0)
parMat[i, (which(chroms %in% c(floor(x), ceiling(x))) +
split)] <- 13
}
parMat[i, (i - split)] <- 9
if (i == (nrow(parMat) - 1))
parMat[(i + 1), (i + 1 - split)] <- 9
parMat[i, (i + 1)] <- 3
parMat[(i + 1), i] <- 4
}
}
return(parMat)
}
library(castor)
library(ape)
library(phytools)
library(geiger)
#-------Make Some Data---------
tree <- sim.bdtree(b=3,d=0, stop="taxa",n=25)
tree$edge.length <- tree$edge.length/max(branching.times(tree))
Q <- matrix(0,10,10)
rate <- 1.5
for(i in 1:10){# rows
for(j in 1:10){# columns
if((i+1) == j){
Q[i,j] <- rate
}
if(i==(j+1)){
Q[i,j] <- rate
}
}
}
diag(Q) <- -rowSums(Q)
colnames(Q) <- 1:10
rowSums(Q)
tip.states<- sim.char(phy=tree, par=Q, root=5, model="discrete")[,,1]
rm(list=ls()[-c(3,5,6)])
tree <- sim.bdtree(b=3,d=0, stop="taxa",n=25)
tree$edge.length <- tree$edge.length/max(branching.times(tree))
plot(tree)
Q <- matrix(0,10,10)
rate <- 1.5
for(i in 1:10){# rows
for(j in 1:10){# columns
if((i+1) == j){
Q[i,j] <- rate
}
if(i==(j+1)){
Q[i,j] <- rate
}
}
}
diag(Q) <- -rowSums(Q)
colnames(Q) <- 1:10
rowSums(Q)
tip.states<- sim.char(phy=tree, par=Q, root=5, model="discrete")[,,1]
rm(list=ls()[-c(3,5,6)])
#--------This is your Function-----
GetTipRates <- function(tree, Q, tip.states){
recon <- asr_mk_model( tree = tree,
tip_states = tip.states,
transition_matrix = Q,
Nstates = ncol(Q),
include_ancestral_likelihoods = TRUE)
est <- c()
for(i in 1:nrow(recon$ancestral_likelihoods)){
est[i] <- which.max(as.vector(recon$ancestral_likelihoods[i,]))
}
## first get the node numbers of the tips
tips <- tree$tip.label
nodes<-sapply(tips,function(x,y) which(y==x),y=tree$tip.label)
## then get the edge lengths for those nodes
edge.lengths<-setNames(tree$edge.length[sapply(nodes,
function(x,y) which(y==x),y=tree$edge[,2])],names(nodes))
tiprates <- nodepulls <- c()
for(i in 1:length(tree$tip.label)){
nodepulls[i] <- getParent(tree, nodes[i])-length(tree$tip.label)
}
tip.changes <- abs(est[nodepulls]-tip.states)
names(tip.changes) <- tree$tip.label
tiprate <- tip.changes/edge.lengths
return(tiprate)
}
rates <- GetTipRates(tree=tree,Q=Q, tip.states=tip.states)
plotTree.barplot(tree, rates, tip.labels=F)
tiplabels(text=tip.states,adj=c(0,.5), cex=.8, frame="none")
#read in the libraries needed for the analysis
library(data.table)
library(evobiR)
setwd("~/Documents/GitHub/carnivores/scripts")
#Michelle Jonika
#september 7, 2021
#creates a phylogenetic plot visualizing chromosome number and range size as a
#discrete trait
###LOAD IN PACKAGES###----------------------------------------------------------
library(viridis)
library(ape)
###LOAD IN DATA###--------------------------------------------------------------
#load in tree data
trees <- read.nexus("../../data/carnivora.nex")
for(i in 1:100){
#trees are ultrametric, this line corrects for the fact that the tolerance
#for being ultrametric is not met by some trees
trees[[i]] <- force.ultrametric(trees[[i]], method = "extend")
}
#load in tip rate data
tips <- read.csv("../../results/rates.csv", row.names = 1)
###PRUNE DATA###----------------------------------------------------------------
#prune and scale trees
#find tips that are missing from the dataset
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% tips$species]
#empty list to store pruned trees
trees.pruned <- list()
#empty vector to store tree depths
#keep tree depths to correct for depth when analysing rates
tree.depths <- c()
#loop that drops missing tips and stores tree depths for further use
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
tree.depths[i] <- max(branching.times(cur.tree))
# a rounding error also makes tree 52 fail due to a multitomy in the genus
# pusa
if(i == 52){
cur.tree <- multi2di(cur.tree)
}
cur.tree$edge.length <-  cur.tree$edge.length / max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
#rm old data and clean up environment
rm(trees, cur.tree, i, missing, tree.depths)
###PLOT PHYLOGENY AND BAR PLOT###--------------------------------------
#plot phylogeny to piece figure together
plot.phylo(trees.pruned[[50]], show.tip.label = F)
setwd("~/Documents/GitHub/carnivores/figures/fig1")
#Michelle Jonika
#september 7, 2021
#creates a phylogenetic plot visualizing chromosome number and range size as a
#discrete trait
###LOAD IN PACKAGES###----------------------------------------------------------
library(viridis)
library(ape)
###LOAD IN DATA###--------------------------------------------------------------
#load in tree data
trees <- read.nexus("../../data/carnivora.nex")
for(i in 1:100){
#trees are ultrametric, this line corrects for the fact that the tolerance
#for being ultrametric is not met by some trees
trees[[i]] <- force.ultrametric(trees[[i]], method = "extend")
}
#load in tip rate data
tips <- read.csv("../../results/rates.csv", row.names = 1)
###PRUNE DATA###----------------------------------------------------------------
#prune and scale trees
#find tips that are missing from the dataset
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% tips$species]
#empty list to store pruned trees
trees.pruned <- list()
#empty vector to store tree depths
#keep tree depths to correct for depth when analysing rates
tree.depths <- c()
#loop that drops missing tips and stores tree depths for further use
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
tree.depths[i] <- max(branching.times(cur.tree))
# a rounding error also makes tree 52 fail due to a multitomy in the genus
# pusa
if(i == 52){
cur.tree <- multi2di(cur.tree)
}
cur.tree$edge.length <-  cur.tree$edge.length / max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
#rm old data and clean up environment
rm(trees, cur.tree, i, missing, tree.depths)
###PLOT PHYLOGENY AND BAR PLOT###--------------------------------------
#plot phylogeny to piece figure together
plot.phylo(trees.pruned[[50]], show.tip.label = F)
#plot barplot with chromosome number to piece figure together
barplot(height = tips$hap.chrom + 1,
col=viridis(2, option= "G", end = 0.6)[tips$range.size + 1],
horiz = T,
xlim = c(0,40),
main = "Chromosome Number")
show_col(viridis_pal()(20))
show_col
help(show_col)
library(scales)
show_col(viridis_pal()(20))
viridis(2, option= "G", end = 0.6)
col <- c("FDE725FF", "39568CFF")
#plot barplot with chromosome number to piece figure together
barplot(height = tips$hap.chrom + 1,
col=c("FDE725FF", "39568CFF")[tips$range.size + 1],
horiz = T,
xlim = c(0,40),
main = "Chromosome Number")
#plot barplot with chromosome number to piece figure together
barplot(height = tips$hap.chrom + 1,
col=c("#FDE725FF", "#39568CFF")[tips$range.size + 1],
horiz = T,
xlim = c(0,40),
main = "Chromosome Number")
#Michelle Jonika
#september 7, 2021
#creates a phylogenetic plot visualizing chromosome number and range size as a
#discrete trait
###LOAD IN PACKAGES###----------------------------------------------------------
library(phytools)
library(chromePlus)
library(viridis)
###LOAD IN DATA###--------------------------------------------------------------
#load in tree data
trees <- read.nexus("../data/carnivora.nex")
for(i in 1:100){
#trees are ultrametric, this line corrects for the fact that the tolerance
#for being ultrametric is not met by some trees
trees[[i]] <- force.ultrametric(trees[[i]], method = "extend")
}
#load in chromosome data
chroms <- read.csv("../data/chroms.csv")
#load in range size
range <- read.csv("../data/calc.carn.range.sizes.csv")
#change column names to be informative
colnames(range) <- c("species", "range.size")
###PRUNE DATA###----------------------------------------------------------------
#prune chromosome number and combnine with range size
dat.pruned <- range
#add empty third column for chromosome number
dat.pruned[, 3]  <- NA
#name the third column
colnames(dat.pruned)[3] <- "hap.chrom"
# Columns are out of order lets fix them immediately
dat.pruned <- dat.pruned[, c(1, 3, 2)]
#this loop creates 100 datasets, sampling a chromosome number for each species
#when there is more than one
datalist <- list()
for(j in 1:100){
for(i in 1:nrow(range)){
hit <- which(chroms$species == range$species[i])
if(length(hit) > 1){
hit <- sample(hit, 1)
}
dat.pruned$hap.chrom[i] <- chroms[hit, 2]
}
datalist[[j]] <- dat.pruned
}
#prune and scale trees
#find tips that are missing from the dataset
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% datalist[[1]]$species]
#empty list to store pruned trees
trees.pruned <- list()
#empty vector to store tree depths
#keep tree depths to correct for depth when analysing rates
tree.depths <- c()
#loop that drops missing tips and stores tree depths for further use
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
tree.depths[i] <- max(branching.times(cur.tree))
# a rounding error also makes tree 52 fail due to a multitomy in the genus
# pusa
if(i == 52){
cur.tree <- multi2di(cur.tree)
}
cur.tree$edge.length <-  cur.tree$edge.length / max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
#rm old data and clean up environment
rm(trees, cur.tree, i, j, missing, chroms, dat.pruned, range, hit)
###DISCRETIZE RANGE SIZES###----------------------------------------------------
#discretize range size based on the median
for(i in 1:100){
x <- median(datalist[[1]]$range.size)
datalist[[i]]$range.size <- as.numeric(datalist[[1]]$range.size >= x)
}
#0 = small; 1 = large pop size
rm(i, x)
###CONTINUOUS TRAIT MAP###------------------------------------------------------
#create a vector of chromosome numbers for barplot
chroms <- datalist[[1]]$hap.chrom
names(chroms) <- datalist[[1]]$species
#use plot tree with bars to create a phylogenetic tree with barplots for the
#chromosome number
dotTree(tree = trees.pruned[[1]], x = chroms, standardize = F,
data.type = "continuous", length = 40, fsize = 0.7)
p4d <- phylo4d(trees.pruned[[1]], chroms)
plotTree.barplot(tree = trees.pruned[[1]],
x = chroms,
lwd=4,
args.plotTree =
list(ftype = "off"),
args.barplot =
list(c("#FDE725FF", "#39568CFF")[datalist[[1]]$range.size + 1],
xlab = "Chromosome Number"),
args.axis = list(at = seq(0,40, by = 5)))
legend(x = "topright",
legend = c("Small Range Size", "Large Range Size"),
pch = 22,
pt.cex = 2,
box.col = "transparent",
pt.bg = c("#FDE725FF", "#39568CFF"))
help(dotTree)
ibrary(phytools)
libraru(phytools)
library(phytools)
#Michelle Jonika
#september 7, 2021
#creates a phylogenetic plot visualizing chromosome number and range size as a
#discrete trait
###LOAD IN PACKAGES###----------------------------------------------------------
library(phytools)
library(chromePlus)
library(viridis)
###LOAD IN DATA###--------------------------------------------------------------
#load in tree data
trees <- read.nexus("../data/carnivora.nex")
for(i in 1:100){
#trees are ultrametric, this line corrects for the fact that the tolerance
#for being ultrametric is not met by some trees
trees[[i]] <- force.ultrametric(trees[[i]], method = "extend")
}
#load in chromosome data
chroms <- read.csv("../data/chroms.csv")
#load in range size
range <- read.csv("../data/calc.carn.range.sizes.csv")
#change column names to be informative
colnames(range) <- c("species", "range.size")
###PRUNE DATA###----------------------------------------------------------------
#prune chromosome number and combnine with range size
dat.pruned <- range
#add empty third column for chromosome number
dat.pruned[, 3]  <- NA
#name the third column
colnames(dat.pruned)[3] <- "hap.chrom"
# Columns are out of order lets fix them immediately
dat.pruned <- dat.pruned[, c(1, 3, 2)]
#this loop creates 100 datasets, sampling a chromosome number for each species
#when there is more than one
datalist <- list()
for(j in 1:100){
for(i in 1:nrow(range)){
hit <- which(chroms$species == range$species[i])
if(length(hit) > 1){
hit <- sample(hit, 1)
}
dat.pruned$hap.chrom[i] <- chroms[hit, 2]
}
datalist[[j]] <- dat.pruned
}
#prune and scale trees
#find tips that are missing from the dataset
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% datalist[[1]]$species]
#empty list to store pruned trees
trees.pruned <- list()
#empty vector to store tree depths
#keep tree depths to correct for depth when analysing rates
tree.depths <- c()
#loop that drops missing tips and stores tree depths for further use
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
tree.depths[i] <- max(branching.times(cur.tree))
# a rounding error also makes tree 52 fail due to a multitomy in the genus
# pusa
if(i == 52){
cur.tree <- multi2di(cur.tree)
}
cur.tree$edge.length <-  cur.tree$edge.length / max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
#rm old data and clean up environment
rm(trees, cur.tree, i, j, missing, chroms, dat.pruned, range, hit)
###DISCRETIZE RANGE SIZES###----------------------------------------------------
#discretize range size based on the median
for(i in 1:100){
x <- median(datalist[[1]]$range.size)
datalist[[i]]$range.size <- as.numeric(datalist[[1]]$range.size >= x)
}
#0 = small; 1 = large pop size
rm(i, x)
###CONTINUOUS TRAIT MAP###------------------------------------------------------
#create a vector of chromosome numbers for barplot
chroms <- datalist[[1]]$hap.chrom
names(chroms) <- datalist[[1]]$species
setwd("~/Documents/GitHub/carnivores/scripts")
#Michelle Jonika
#september 7, 2021
#creates a phylogenetic plot visualizing chromosome number and range size as a
#discrete trait
###LOAD IN PACKAGES###----------------------------------------------------------
library(phytools)
library(chromePlus)
library(viridis)
###LOAD IN DATA###--------------------------------------------------------------
#load in tree data
trees <- read.nexus("../data/carnivora.nex")
for(i in 1:100){
#trees are ultrametric, this line corrects for the fact that the tolerance
#for being ultrametric is not met by some trees
trees[[i]] <- force.ultrametric(trees[[i]], method = "extend")
}
#load in chromosome data
chroms <- read.csv("../data/chroms.csv")
#load in range size
range <- read.csv("../data/calc.carn.range.sizes.csv")
#change column names to be informative
colnames(range) <- c("species", "range.size")
###PRUNE DATA###----------------------------------------------------------------
#prune chromosome number and combnine with range size
dat.pruned <- range
#add empty third column for chromosome number
dat.pruned[, 3]  <- NA
#name the third column
colnames(dat.pruned)[3] <- "hap.chrom"
# Columns are out of order lets fix them immediately
dat.pruned <- dat.pruned[, c(1, 3, 2)]
#this loop creates 100 datasets, sampling a chromosome number for each species
#when there is more than one
datalist <- list()
for(j in 1:100){
for(i in 1:nrow(range)){
hit <- which(chroms$species == range$species[i])
if(length(hit) > 1){
hit <- sample(hit, 1)
}
dat.pruned$hap.chrom[i] <- chroms[hit, 2]
}
datalist[[j]] <- dat.pruned
}
#prune and scale trees
#find tips that are missing from the dataset
missing <- trees[[1]]$tip.label[!trees[[1]]$tip.label %in% datalist[[1]]$species]
#empty list to store pruned trees
trees.pruned <- list()
#empty vector to store tree depths
#keep tree depths to correct for depth when analysing rates
tree.depths <- c()
#loop that drops missing tips and stores tree depths for further use
for(i in 1:100){
cur.tree <- drop.tip(trees[[i]], tip = missing)
tree.depths[i] <- max(branching.times(cur.tree))
# a rounding error also makes tree 52 fail due to a multitomy in the genus
# pusa
if(i == 52){
cur.tree <- multi2di(cur.tree)
}
cur.tree$edge.length <-  cur.tree$edge.length / max(branching.times(cur.tree))
trees.pruned[[i]] <- cur.tree
}
#rm old data and clean up environment
rm(trees, cur.tree, i, j, missing, chroms, dat.pruned, range, hit)
###DISCRETIZE RANGE SIZES###----------------------------------------------------
#discretize range size based on the median
for(i in 1:100){
x <- median(datalist[[1]]$range.size)
datalist[[i]]$range.size <- as.numeric(datalist[[1]]$range.size >= x)
}
#0 = small; 1 = large pop size
rm(i, x)
###CONTINUOUS TRAIT MAP###------------------------------------------------------
#create a vector of chromosome numbers for barplot
chroms <- datalist[[1]]$hap.chrom
names(chroms) <- datalist[[1]]$species
#use plot tree with bars to create a phylogenetic tree with barplots for the
#chromosome number
dotTree(tree = trees.pruned[[1]], x = chroms, standardize = F,
data.type = "continuous", length = 40, fsize = 0.7)
help(phylo4d)
library(phylobase)
p4d <- phylo4d(trees.pruned[[1]], chroms)
plotTree.barplot(tree = trees.pruned[[1]],
x = chroms,
lwd=4,
args.plotTree =
list(ftype = "off"),
args.barplot =
list(c("#FDE725FF", "#39568CFF")[datalist[[1]]$range.size + 1],
xlab = "Chromosome Number"),
args.axis = list(at = seq(0,40, by = 5)))
